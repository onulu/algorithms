---
title: Majority Element
tags:
  - array
level: easy
date: 2024-06-18
link: https://leetcode.com/problems/majority-element/
---

## 문제 요약

주어진 배열에서 [n / 2]번 이상 등장하는 요소를 찾는 문제이다.

```text
Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2
```

## 접근 방법

`n/k` 번 이상 등장한다는 것은 `k-1`번 등장한다는 뜻으로 해석할 수 있다.
이 문제는 hash map을 사용해서 각 요소의 빈도수를 계산하는 방법과 보이어 무어의 투표 알고리즘을 사용하는 방법이 있다.

### Boyer Moore Voting Algorithm

보이어 무어의 투표 알고리즘은 주어진 배열에서 각각 요소의 빈도수를 별도로 계산하지 않고 후보 요소를 찾는 알고리즘이다.
이게 가능한 이유는 주어진 배열에서 `n/k`번 이상 등장하는 요소가 있다면, 나머지 요소는 `n/k`번 이상 등장하는 요소의 빈도수를 줄일 것이기 때문이다.
예를 들어 배열의 길이가 4이고 n/2는 2이다. 만약 2번 이상 등장하는 요소가 있다면, 나머지 요소는 1번 이하로 등장할 것이다.
따라서 배열을 순회하면서 후보 요소를 지정하고, 그 외의 요소를 만날 경우 후보의 카운트를 줄이는 방식으로 최종 후보를 찾을 수 있다.

['a', 'b', 'a', 'a']
처음에 a라는 요소가 나왔다면 a가 후보가 되고 카운트는 1이 된다.
요소가 b라면 지금 후보였던 a의 카운트를 한 개 감소시킨다.
요소는 a이고, 카운트는 0이므로, 현재 요소인 a를 다시 후보로 설정한다. 카운트는 1이 된다.
요소는 a이고, 현재 후보와 요소가 같으므로 카운트를 증가시킨다. 카운트는 2가 된다.
카운트는 n/2보다 크므로 후보인 a를 반환한다.


- majority후보를 담을 수 있는 `m`변수와, 빈도수를 카운트할 `c`변수를 생성하고 초깃값을 설정한다.
- 배열을 순회하면서 n에 대하여,
  1. `c === 0`이면 후보인 `m`을 현재 요소인 `n`으로 설정한다.
  2. `n === m`인 경우, `c`를 증가시킨다.
  3. `n !== m`인 경우, `c`를 감소시킨다.
- 최종 후보인 `m`을 반환한다. 


```js
var majorityElement = function(nums) {
  let candidate = null;
  let count = 0;

  for (let num of nums) {
    if (count === 0) {
      candidate = num;
    }

    count += (num === candidate) ? 1 : -1;
  }

  return candidate;
}
```
