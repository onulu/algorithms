# Binary Search

탐색은 알고리즘에서 중요한 개념 중 하나이다.
우리에게 리스트에서 무언가를 찾는 일은 어렵지 않고 일상적인 일로 느껴질 수 있지만, 컴퓨터에게는 결코 당연한 일이 아니다.
컴퓨터는 단순히 명령을 수행하는 기계일 뿐이기 때문에 컴퓨터에게 무언가를 찾게 하려면 그 방법을 아주 세밀하게 지시해야 한다.

예를 들어 긴 명단에서 접수 번호나 이름을 찾을 때 우리는 대부분 이진 탐색을 사용하고 있다.
투표소에서 투표 명단을 찾을때 성이 '오'씨인 사람을 찾는 경우, 처음부터 끝까지 차례로 찾는 것이 아니라 중간부터 찾아보는게 훨씬 더 효율적이라는 것을 알고 있다.
바로 이렇게 무언가를 찾는것을 알고리즘에서는 탐색이라고 하며 그중 이진 탐색은 가장 효율적인 방법 중 하나이다.

이진 탐색은 Binary Search라고도 하며 정렬된 배열(Sorted Array)에서 특정 값의 위치를 찾는 알고리즘이다. 
이진 탐색은 이름에서도 알 수 있듯이 배열의 중간값을 기준으로 두 부분으로 나누어 탐색 범위를 반씩 줄여가며 값을 찾는다.
이렇게 문제를 작은 단위로 쪼개서 해결하는 방식을 Divide and Conquer(분할 정복) 접근법이라고 한다.

매 반복마다 탐색의 범위를 아주 급격하게 반토막 내기 때문에, 이진 탐색은 매우 빠른 `O(log n)`의 시간 복잡도를 가지며, 배열의 크기가 1,000,000이라고 할 때 최대 20번의 비교만으로 값을 찾을 수 있다.

## 작동 원리 및 구현 방법

문제: 배열과 찾는 값이 주어졌을 때, 찾는 값의 인덱스를 반환하라. 없다면 -1을 반환하라.
조건: 배열은 오름차순으로 정렬되어 있다.

0. 배열의 시작과 끝 인덱스를 변수로 선언한다.
1. 배열의 사이즈가 0이 될때까지 반복한다.
   1. 중간값 계산 (start + end) / 2
   2. 중간값이 찾는 값과 같다면 인덱스를 반환한다. (운좋게 찾았다!)
   3. 중간값이 찾는 값보다 작다. -> 왼쪽 부분 배열을 1번부터 반복한다. (start ~ (mid - 1))
   4. 중간값이 찾는 값보다 크다. -> 오른쪽 부분 배열을 1번부터 반복한다. ((mid + 1) ~ end)
  
## 구현

```js
function binarySearch(arr, target) {
  let start = 0;
  let end = arr.length - 1;

  while (start <= end) {
    let mid = Math.floor((start + end) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      start = mid + 1;
    } else {
      end = mid - 1;
    }
  }

  return -1;
}
```
